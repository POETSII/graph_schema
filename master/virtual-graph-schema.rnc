datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

default namespace = "http://TODO.org/POETS/virtual-graph-schema-v0"

grammar {

  start = element Graph{
    ( graphType | graphTypeReference )*,
    graphInstance*
  }

  graphType =
    element GraphType {
      ## Identifier or name for the graph.
      attribute id { string },

      ## Gives the native dimension of the problem, if there is one. Zero if not set of if not applicable.
      ## For example in a 2D heat equation this would be 2.
      attribute native_dimension { xsd:integer } ? ,

      ## Global properties that are shared with all nodes at run-time. read-only.
      element Properties {
        typedData *
      } ? ,

      ## Establishes the different types of edges that could exist in the graph,
      ## and any properties or state associated with each edge type
      element EdgeTypes {
        edgeType *
      },
      ## This establishes the shapes of devices, though not the internals.
      element DeviceTypes {
        deviceType *
      }
   }

   graphTypeReference =
     ## This is used when we want the graph type to live in a different file, or
     ## to use a graph-type that is defined by a software provider
     element GraphTypeReference {
       attribute id { string},

       ## This may be missing, in which case it is assumed some other mechanism will
       ## connect it up
       attribute src { string } ?
     }

   graphInstance =
     element GraphInstance {

      attribute id { string },

      ## The graph type must have been declared using either a GraphType or a GraphTypeReference
      attribute graphTypeId { string },

      element Properties {
      	typedData *
      } ?,

      element DeviceInstances {
        deviceInstance *
      },
      element EdgeInstances {
        edgeInstance *
      }
    }

  edgeType =
    ## An edge type captures a type of communication that could happen between ports
    element EdgeType {
      ## Must be unique amongst all edge types
      attribute  id { string },

      ## The type of messages that are sent over this edge. This may not exist
      ## (e.g. if it is only a pulse)
      element Message {
        typedData *
      } ?,

      ## Indicates read-only properties associated with each edge. This will be
      ## delivered along-side messages which arrive along that edge
      ## An edge may have no properties, in which case this element will not exist
      element Properties {
        typedData *
      } ?,

      ## Indicates mutable properties associated with an edge.
      ## TODO : This has unclear semantics (which is why I (DBT) was hesitant about it).
      ##        When is the state modifiable, is it _only_ when a message arrives over
      ##        that edge? Should there be state associated with outgoing edges?
      element State {
        typedData
      } ?
    }

  deviceType =
    ## A device type captures a piece of structure and functionality that can
    ## be instantiated within the graph. All devices of the same type are identical
    ## except for the functionality they have.
    ##
    ## The number of ports must be fixed, but we allow a variable number of
    ## edges to enter or leave a node. Alongside the edge properties and
    ## edge state this provides storage that scales with the number of edges.
    ##
    ## Messages are delivered to the device in any order, and a device has no
    ## way of avoiding them.
    ##
    ## Devices can request a send on a particular port NAME by setting requestSend_NAME.
    ## The value of requestSend_NAME will persist between calls until a send is
    ## achieved on a particular port.
    element DeviceType {
      ## Must be unique amongst all device types
      attribute id { string },

      ## Read-only properties that could be specified on the device. This element
      ## may not appear if the device has no properties. There may be default
      ## values specified for some or all components of the properties.
      element Properties { typedData * } ?,

      ## Mutable properties attached to the device. In principle this element might
      ## not appear, if the device has no state (I suppose all the mutable state could
      ## be in the edge properties).
      element State { typedData * } ?,

      ## Zero or more input ports that appear on the device type.
      element InputPort {
        ## Name of the port, must be unique within the device type
        attribute name { string },

        ## Identifies the edge type for this port (specifying properties+state space)
	## A port can only be connected to an edge of the same type (not just structurally,
	## they must have the same edgeTypeId)
	attribute edgeTypeId { string },

        ## Event handler for when a message arrives on this device. The body will
	## be a fragment of C. It should probably be wrapped in a CDATA section,
	## but that is up to you. The code should be a statement or sequence of
	## statements, and does not contain any function header.
	##
        ## Rationale: why a fragment? It forces the implementer to not use globals etc.,
	## and means we have control over the type names of the various structs.
	## TODO: I (DBT) am not convinced that using fragments is a good idea (this
	## is true even as I specify it). Using a reference to functions in the C
	## code would make much more sense.
	##
	## Variables which will be in scope are:
	##   graphProperties : Read-only pointer to the graph properties
	##   deviceProperties : Read-only pointer to the device state
	##   deviceState : Mutable pointer to the device state
	##   edgeProperties : Read-only pointer to the edge state
	##   edgeState : Mutable pointer to the edge state
	##   message : Read-only pointer to the message payload
	##   requestSend[] : an array of booleans which requests sending on the named port (one bool for each output port)
	element OnReceive {
	  string
	}
      } *,

      ## Zero or more output ports that appear on the device type.
      element OutputPort {
        ## Name of the port, must be unique within the device type
        attribute name { string },

        ## Identifies the edge type for this port (specifying properties+state space)
	## A port can only be connected to an edge of the same type (not just structurally,
	## they must have the same edgeTypeId)
	attribute edgeTypeId { string },

        ## Event handler for sending a message on this device. The body will
	## be a fragment of C. It should probably be wrapped in a CDATA section,
	## but that is up to you. The code should be a statement or sequence of
	## statements, and does not contain any function header.
	##
	## Variables which will be in scope are:
	##   graphProperties : Read-only pointer to the graph properties
	##   deviceProperties : Read-only pointer to the device properties
	##   deviceState : Mutable pointer to the device state
	##   requestSend[] : an array of  booleans which requests sending on the named port (one bool for each port)
	##   message : A mutable pointer to payload associate with the edge
	##   cancelSend : mutable boolean which is true by default. Set to false to cancel the send.
	##
	## Whenever requestSend[index] is high, then eventually this handler will get
	## executed. By default, requestSend[index] will be set low before the handler
	## executes, but the handler can set it high again if it wants.
	element OnSend { string }
      } *
    }

  deviceInstance =
    element DeviceInstance {
      ## A unique string
      attribute id { string },

      ## Links to a previously declared device type
      attribute deviceTypeId { string },

      ## If the device has a natural location (e.g. in the problem space), then this gives it.
      ## The format is decimal values seperated by commas. The number of values should follow
      ## the native dimension of the graph type.
      attribute native_location { string } ?,

      ## Read-only properties associated with this device instance.
      ## This element must not exist if the device type has no properties
      ## This element may not exist if the property has a (complete) default value
      element Properties { typedData } ?
    }

  edgeInstance =
    ## The edgeTypeId can be inferred from the types of the ports,
    ## and it is worth explicitly checking they have the same port on
    ## load, so it is not included here.
    element EdgeInstance {
      attribute dstDeviceId   { xsd:string },
      attribute dstPortName   { xsd:string },
      attribute srcDeviceId   { xsd:string },
      attribute srcPortName   { xsd:string },

      ## Read-only properties associated with this edge instance
      ## This element can only exist if the edge has properties.
      ## This edge may not exist if all properties have a default
      element Properties { typedData } ?,

      ## Mutable properties associated with this edge instance.
      ## This element can only exist if the edge has state
      ## This edge may not exist if all parts of the state have a default.
      element State { typedData } ?
    }

  typedData =
  ## This represents either a prototype for a typed piece of data, or
  ## as an instance of the data itself.
  ## As a prototype, each typedData spec also has a 64-bit typeHash
  ## for sanity checking purposes (e.g. checking that a dynamic
  ## configuration matches a compiled static provider).
  ##
  ## Hashes are done using FNV1a in 64-bit mode.
  ##
  ## Positive integers are hashed from least-significant byte
  ## to most significant, until there are no more non-zero bytes.
  ## Negative integers are hashed as 0xCC followed by the hash of
  ## the value+1 (to avoid twos-complement overflow problems):
  ##
  ## def hash_int(hash, x):
  ##   if x<0: return hash_int(hash_byte(0xCC), -(x+1))
  ##   while True:
  ##      hash=hash_byte(hash,x&0xFF)
  ##      x=x>>8
  ##      if x==0: break
  ##   return hash
  ##
  ## Strings are hashed as their ascii values from first to last character.
  ##
  ## Hashes are combined by hashing each octet of the the LHS into the RHS,
  ## from LSO to MSO
  (
    element Int32 {
      ## typeHash is name -> "Int32"
      attribute name { string },
      attribute value { xsd:integer } ?
    }
    |
    element Float32 {
      ## typeHash is name -> "Float32"
      attribute name { string },
      attribute value { xsd:float } ?
    }
    |
    element Bool {
      ## typeHash is name -> "Bool"
      attribute name { string },
      attribute value { text } ?
    }
    |
    element Tuple {
      ## typeHash is name -> "Tuple" -> typeHash(elt1) -> typeHash(elt2) -> ...
        attribute name { text },
        typedData *
    }
  )



}
