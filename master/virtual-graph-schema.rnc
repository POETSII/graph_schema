datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

default namespace = "TODO/POETS/virtual-graph-schema-v0"

grammar {
  start = element Graph{
    graphType*,
    graphInstance*
  }

  graphType =
    element GraphType {
      ## Identifier or name for the graph.
      attribute id { string },

      ## Global properties that are shared with all nodes. read-only.
      element Properties {
        typedData
      } ? ,

      ## Establishes the different types of edges that could exist in the graph,
      ## and any properties or state associated with each edge type
      element EdgeTypes {
        edgeType *
      },
      ## This establishes the shapes of devices, though not the internals.
      element DeviceTypes {
        deviceType *
      }
   }

   graphInstance =
     element GraphInstance {
      attribute id { string },
      attribute graphTypeId { string },

      element Properties {
      	typedData
      } ?,

      element DeviceInstances {
        deviceInstance *
      },
      element EdgeInstances {
        edgeInstance *
      }
    }

  edgeType =
    ## An edge type captures a type of communication that could happen between ports
    element EdgeType {
      ## Must be unique amongst all edge types
      attribute  id { string },

      ## The type of messages that are sent over this edge. This may not exist
      ## (e.g. if it is only a pulse)
      element Message {
        typedData
      } ?,

      ## Indicates read-only properties associated with each edge. This will be
      ## delivered along-side messages which arrive along that edge
      ## An edge may have no properties, in which case this element will not exist
      element Properties {
        typedData
      } ?,

      ## Indicates mutable properties associated with an edge.
      ## TODO : This has unclear semantics (which is why I (DBT) was hesitant about it).
      ##        When is the state modifiable, is it _only_ when a message arrives over
      ##        that edge? Should there be state associated with outgoing edges?
      element State {
        typedData
      } ?
    }

  deviceType =
    ## A device type captures a piece of structure and functionality that can
    ## be instantiated within the graph. All devices of the same type are identical
    ## except for the functionality they have.
    ##
    ## The number of ports must be fixed, but we allow a variable number of
    ## edges to enter or leave a node. Alongside the edge properties and
    ## edge state this provides storage that scales with the number of edges.
    ##
    ## Messages are delivered to the device in any order, and a device has no
    ## way of avoiding them.
    ##
    ## Devices can request a send on a particular port NAME by setting requestSend_NAME.
    ## The value of requestSend_NAME will persist between calls until a send is
    ## achieved on a particular port.
    element DeviceType {
      ## Must be unique amongst all device types
      attribute id { string },

      ## Read-only properties that could be specified on the device. This element
      ## may not appear if the device has no properties. There may be default
      ## values specified for some or all components of the properties.
      element Properties { typedData } ?,

      ## Mutable properties attached to the device. In principle this element might
      ## not appear, if the device has no state (I suppose all the mutable state could
      ## be in the edge properties).
      element State { typedData } ?,

      ## Zero or more input ports that appear on the device type.
      element InputPort {
        ## Name of the port, must be unique within the device type
        attribute name { string },

        ## Identifies the edge type for this port (specifying properties+state space)
	## A port can only be connected to an edge of the same type (not just structurally,
	## they must have the same edgeTypeId)
	attribute edgeTypeId { string },

        ## Event handler for when a message arrives on this device. The body will
	## be a fragment of C. It should probably be wrapped in a CDATA section,
	## but that is up to you. The code should be a statement or sequence of
	## statements, and does not contain any function header.
	##
        ## Rationale: why a fragment? It forces the implementer to not use globals etc.,
	## and means we have control over the type names of the various structs.
	## TODO: I (DBT) am not convinced that using fragments is a good idea (this
	## is true even as I specify it). Using a reference to functions in the C
	## code would make much more sense.
	##
	## Variables which will be in scope are:
	##   deviceProperties : Read-only pointer to the device state
	##   deviceState : Mutable pointer to the device state
	##   edgeProperties : Read-only pointer to the edge state
	##   edgeState : Mutable pointer to the edge state
	##   messageData : Read-only pointer to the message payload
	##   requestSend[] : an array of booleans which requests sending on the named port (one bool for each output port)
	element OnReceive {
	  string
	}
      } *,

      ## Zero or more output ports that appear on the device type.
      element OutputPort {
        ## Name of the port, must be unique within the device type
        attribute name { string },

        ## Identifies the edge type for this port (specifying properties+state space)
	## A port can only be connected to an edge of the same type (not just structurally,
	## they must have the same edgeTypeId)
	attribute edgeTypeId { string },

        ## Event handler for sending a message on this device. The body will
	## be a fragment of C. It should probably be wrapped in a CDATA section,
	## but that is up to you. The code should be a statement or sequence of
	## statements, and does not contain any function header.
	##
	## Variables which will be in scope are:
	##   deviceProperties : Read-only pointer to the device state
	##   deviceState : Mutable pointer to the device state
	##   requestSend[] : an array of  booleans which requests sending on the named port (one bool for each port)
	##   messageData : A mutable pointer to payload associate with the edge
	##   cancelSend : mutable boolean which is true by default. Set to false to cancel the send.
	##
	## Whenever requestSend[index] is high, then eventually this handler will get
	## executed. By default, requestSend[index] will be set low before the handler
	## executes, but the handler can set it high again if it wants.
	element OnSend { string }
      } *
    }

  deviceInstance =
    element DeviceInstance {
      ## A unique string
      attribute id { string },

      ## Links to a previously declared device type
      attribute deviceTypeId { string },

      ## Read-only properties associated with this device instance.
      ## This element must not exist if the device type has no properties
      ## This element may not exist if the property has a (complete) default value
      element Properties { typedData } ?
    }

  edgeInstance =
    element EdgeInstance {
      attribute edgeTypeId { string },

      attribute dstDeviceId   { xsd:string },
      attribute dstPortName   { xsd:string },
      attribute srcDeviceId   { xsd:string },
      attribute srcPortName   { xsd:string },

      ## Read-only properties associated with this edge instance
      ## This element can only exist if the edge has properties.
      ## This edge may not exist if all properties have a default
      element Properties { typedData } ?,

      ## Mutable properties associated with this edge instance.
      ## This element can only exist if the edge has state
      ## This edge may not exist if all parts of the state have a default.
      element State { typedData } ?
    }

  typedData = (
    element Int32 {
      attribute name { string },
      attribute value { xsd:integer } ?
    }
    |
    element Float32 {
      attribute name { string },
      attribute value { xsd:float } ?
    }
    |
    element Bool {
      attribute name { string },
      attribute value { text } ?
    }
    |
    element Tuple {
        attribute name { text },
        typedData *
    }
  )
   
}