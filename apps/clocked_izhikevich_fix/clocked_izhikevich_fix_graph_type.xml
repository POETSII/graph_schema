<?xml version="1.0"?>
<Graphs xmlns="http://TODO.org/POETS/virtual-graph-schema-v1">
  <GraphType id="clocked_izhikevich_fix">

    <Properties>
    </Properties>

    <SharedCode><![CDATA[

    constexpr int32_t fix_from_real(double x)
    { return (int32_t)(x*65536); }

    int32_t fix_from_int(int32_t x)
    {
      return x<<16;
    }

    int32_t fix_mul(int32_t x, int32_t y)
		{
			auto xy=x*(int64_t)y;
			xy += (1<<15);
			xy = xy>>16;
			assert( -2147483648 <= xy && xy <= 2147483647 );
			return (int32_t)(xy);
		}
    
    int32_t fix_mul(int32_t a, int32_t b, int32_t c)
    { return fix_mul(fix_mul(a,b),c); }

		int32_t fix_add(int32_t x, int32_t y)
		{
			int64_t xy64=x+(int64_t)y;
			assert( -2147483648 <= xy64 && xy64 <= 2147483647 );
			int32_t xy=x+y;
			return xy;
		}

    int32_t fix_add(int32_t x, int32_t y, int32_t z)
    { return fix_add(fix_add(x,y),z); }

    int32_t fix_add(int32_t x, int32_t y, int32_t z, int32_t a)
    { return fix_add(fix_add(x,y),fix_add(z,a)); }

    int32_t fix_add(int32_t x, int32_t y, int32_t z, int32_t a, int32_t b)
    { return fix_add(fix_add(x,y),fix_add(z,fix_add(a,b))); }

		int32_t fix_sub(int32_t x, int32_t y)
		{
			int64_t xy64=x-(int64_t)y;
			assert( -2147483648 <= xy64 && xy64 <= 2147483647 );
			int32_t xy=x-y;
			return xy;
		}

		bool fix_gt(int32_t x, int32_t y)
		{
			return x>y;
		}

    bool fix_gte(int32_t x, int32_t y)
		{
			return x>=y;
		}

		bool fix_lt(int32_t x, int32_t y)
		{
			return x>y;
		}


    uint32_t urng(uint32_t &state)
    {
      state = state*1664525+1013904223;
      return state;
    }

    // Worlds crappiest gaussian
    // Now even crappier in fixed-point!!!!
    int32_t grng(uint32_t &state)
    {
      uint32_t u=urng(state);
      int32_t acc=0;
      for(unsigned i=0;i<8;i++){
        acc += u&0xf;
        u=u>>4;
      }
      // a four-bit uniform has mean 7.5 and variance ((15-0+1)^2-1)/12 = 85/4
      // sum of four uniforms has mean 8*7.5=60 and variance of 8*85/4=170
      // const float scale=0.07669649888473704; // == 1/sqrt(170)
      // To get to unit gaussian in 16.16 we need 2^16 / sqrt(170)
      //  = 5026.3817509101268959871720469139
      return (acc-60) * 5026;
    }

    ]]></SharedCode>

    <MessageTypes>
      <MessageType id="__init__">
        <!-- This doesn't have any properties -->
      </MessageType>

      <MessageType id="spike">
        <Message>
          <Scalar type="int8_t" name="fired" />
       </Message>
    </MessageType>

      <MessageType id="tick">
      </MessageType>
    </MessageTypes>

    <DeviceTypes>
      <DeviceType id="neuron">

          <Documentation><![CDATA[

        Overall neuron flow is:

        while(1){
            // ICount==fanin && !waitTick && sentSpike
            RTS={tick}

            send tick [
              // Update state and firing
              ICount=0;
              sentSpike=false;
              waitTick=true;
            ]

            // ICount==0 && waitTick  && !sentSpike
            RTS={}

            par{
                seq{
                    // waitTick && !sentSpike
                    RTS={}
                    recv tick [
                      waitTick=false;
                    ]
                    // !waitTick && !sentSpike
                    RTS={spike}
                    send spike [
                        sentSpike =true;
                    ]
                    // !waitTick && sentSpike
                    RTS={}
                }

                // Icount==0
                while(incomingSpikes < fanIn){
                    // Icount<fanin
                    nextPotential += [recv spike]
                }
                // Icount==fanin
            }

            // ICount==fanin && !waitTick && sentSpike
        }

        ]]></Documentation>

        <Properties>
          <Scalar type="uint32_t" name="seed" />

          <Scalar type="int32_t" name="a" default="0" />
          <Scalar type="int32_t" name="b" default="0" />
          <Scalar type="int32_t" name="c" default="0" />
          <Scalar type="int32_t" name="d" default="0" />
          <Scalar type="int32_t" name="Ir" />

          <Scalar type="uint32_t" name="fanin" />
        </Properties>

        <State>
          <Scalar type="uint32_t" name="rng" />

          <Scalar type="int32_t" name="u" />
          <Scalar type="int32_t" name="v" />

          <Scalar name="I" type="int32_t" />
          <Scalar name="Icount" type="uint32_t" />
          <Scalar name="fireValue" type="int8_t" />

          <Scalar name="waitTick" type="int8_t" />
          <Scalar name="sentSpike" type="int8_t" />
        </State>


        <InputPort name="__init__" messageTypeId="__init__">
          <OnReceive><![CDATA[
          deviceState->rng = deviceProperties->seed;

          deviceState->v=fix_from_int(-65);
          deviceState->u=fix_mul( deviceProperties->b , deviceState->v );

          deviceState->fireValue=false; // We don't fire in the first round

          deviceState->I=fix_mul( deviceProperties->Ir , grng(deviceState->rng) );
          deviceState->Icount=deviceProperties->fanin;
          deviceState->waitTick=false;
          deviceState->sentSpike=true;

          handler_log(3, "sentSpike=%d, waitTick=%d, Icount = %d, fanin=%d", deviceState->sentSpike, deviceState->waitTick, deviceState->Icount, deviceProperties->fanin);
          ]]>
          </OnReceive>
        </InputPort>

        <ReadyToSend><![CDATA[
        *readyToSend=0;
        if(deviceState->Icount==deviceProperties->fanin && !deviceState->waitTick && deviceState->sentSpike ){
            *readyToSend |= OUTPUT_FLAG_tock;
        }else if(!deviceState->waitTick && !deviceState->sentSpike){
            *readyToSend |= OUTPUT_FLAG_fire;
        }
        ]]></ReadyToSend>

        <OutputPort name="tock" messageTypeId="tick">
          <OnSend><![CDATA[
          assert(deviceState->Icount==deviceProperties->fanin);
          assert(!deviceState->waitTick && deviceState->sentSpike);

          int32_t &v=deviceState->v;
          int32_t &u=deviceState->u;
          int32_t &I=deviceState->I;

          const int32_t c_half=fix_from_real(0.5);
          const int32_t c_004=fix_from_real(0.04);
          const int32_t c_5=fix_from_int(5);
          const int32_t c_140=fix_from_int(140);

          handler_log(4, " v=%d, u=%d, I=%d", v, u, I);

          for(int i=0; i<2; i++){
            //v=v+0.5*(0.04*v*v+5*v+140-u+I); // step 0.5 ms
            v=fix_add(
                v,
                fix_mul(
                  c_half,
                  fix_add(
                    fix_mul(c_004,v,v),
                    fix_mul(c_5,v),
                    c_140,
                    -u,
                    I
                  )
                )
              );
              handler_log(4, " v=%d, u=%d, I=%d", v, u, I);
          };

          u=fix_add(u, fix_mul(deviceProperties->a, fix_sub( fix_mul(deviceProperties->b , v) , u) ));

          deviceState->fireValue = fix_gte(v , 30);
          if(deviceState->fireValue){
            handler_log(1, "FIRE!");

            v=deviceProperties->c;
            u =fix_add(u, deviceProperties->d);
          }

          deviceState->I=fix_mul(deviceProperties->Ir , grng(deviceState->rng) );
          deviceState->Icount=0;
          deviceState->sentSpike=false;
          deviceState->waitTick=true;
          handler_log(3, "sentSpike=%d, waitTick=%d, Icount = %d, fanin=%d", deviceState->sentSpike, deviceState->waitTick, deviceState->Icount, deviceProperties->fanin);

          ]]></OnSend>
        </OutputPort>

        <InputPort name="tick" messageTypeId="tick">
          <OnReceive><![CDATA[
          handler_log(3, "sentSpike=%d, waitTick=%d, Icount = %d, fanin=%d", deviceState->sentSpike, deviceState->waitTick, deviceState->Icount, deviceProperties->fanin);

          assert(deviceState->waitTick);
          assert(!deviceState->sentSpike);
          deviceState->waitTick=false;
          ]]></OnReceive>
        </InputPort>

        <OutputPort name="fire" messageTypeId="spike">
          <OnSend><![CDATA[
          handler_log(3, "sentSpike=%d, waitTick=%d, Icount = %d, fanin=%d", deviceState->sentSpike, deviceState->waitTick, deviceState->Icount, deviceProperties->fanin);

          assert(!deviceState->waitTick);
          assert(!deviceState->sentSpike);
          message->fired=deviceState->fireValue;
          deviceState->sentSpike=true;
          ]]></OnSend>
        </OutputPort>

        <InputPort name="input" messageTypeId="spike">
            <Properties>
                <Scalar type="float" name="weight" />
            </Properties>

          <OnReceive><![CDATA[
          assert(deviceState->Icount < deviceProperties->fanin);

          deviceState->Icount++;
          if(message->fired){
            deviceState->I = fix_add(deviceState->I , edgeProperties->weight);
          }

          handler_log(3, "sentSpike=%d, waitTick=%d, Icount = %d, fanin=%d", deviceState->sentSpike, deviceState->waitTick, deviceState->Icount, deviceProperties->fanin);
          ]]></OnReceive>
        </InputPort>

      </DeviceType>

      <DeviceType id="clock">
        <Properties>
          <Scalar type="uint32_t" name="neuronCount" />
        </Properties>

        <State>
          <Scalar type="uint32_t" name="waitCount" />
        </State>

        <InputPort name="__init__" messageTypeId="__init__">
          <OnReceive><![CDATA[
          deviceState->waitCount = deviceProperties->neuronCount;
          handler_log(3,"waitCount=%d, neuronCount=%d", deviceState->waitCount, deviceProperties->neuronCount);
          ]]></OnReceive>
        </InputPort>

        <ReadyToSend><![CDATA[
        *readyToSend = deviceState->waitCount==0 ? OUTPUT_FLAG_tick : 0;
        ]]></ReadyToSend>

        <InputPort name="tock" messageTypeId="tick">
          <OnReceive><![CDATA[
          assert(deviceState->waitCount > 0);
          deviceState->waitCount--;
          handler_log(3,"tock : waitCount = %d\n", deviceState->waitCount);
          ]]></OnReceive>
        </InputPort>

        <OutputPort name="tick" messageTypeId="tick">
          <OnSend><![CDATA[
          handler_log(3,"tick : waitCount = %d\n", deviceState->waitCount);
          assert(deviceState->waitCount==0);
          deviceState->waitCount=deviceProperties->neuronCount;
          ]]></OnSend>
        </OutputPort>

      </DeviceType>
    </DeviceTypes>
  </GraphType>
</Graphs>
