<?xml version="1.0"?>
<Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v2" formatMinorVersion="1">
  <GraphType id="relaxation_heat" >
	<Documentation><![CDATA[
		Supposed to broadly match spinnaker experiments.

		Each cell has a current heat h, and four neighbours n[0..3]. When an update
		arrives the cell will store it in n[x], the calculate h'=sum(n)/4. If
		|h' - h| > 3 then it will update its neighbours.

		This is designed not to use edge properties, so it uses a strictly cartesian
		grid and colours the devices:

       0  1  2  3  4  5  6
     +--------------------
   0 | 0  1  3  2  0  1  3
   1 | 0  2  3  1  0  2  3
   2 | 3  2  0  1  3  2  0
   3 | 3  1  0  2  3  1  0
   4 | 0  1  3  2  0  1  3
   5 | 0  2  3  1  0  2  3
   6 | 3  2  0  1  3  2  0

		Each device broadcasts their colour with their heat, so the heat will always
		get routed to a unique position in the array.

    Termination:
    - Each cell has a nextVersion and currVerson
    - When any cell receives an update, it takes self.nextVersion=max(self.nextVersion,msg.version)
    - When a cell sends a message it does:
       - if abs_diff(self.nextHeat,self.currHeat) <= 3 : self.currVersion=self.nextVersion
       - else: self.currVersion=self.nextVersion+1
    
    Eventually everyone converges on the same version, though convergence speed depends
    on the diameter of the graph.

    Each cell also sends updates upwards through a network which tracks:
    - The largest known version
    - How many cells are at the largest known version

    The pair is then reduced upwards using the function:
      (largest,count) = (max(largestA,largestB), largestA==largestB ? countA+countB : max(countA,countB)

    At the top-level you can guess that termination has happened when count==len(cells). It isn't
    certain though, because n-1 cells could be at version v, with one cell at version v-1... but
    then not, it has to go to version v+1...

    Is it possible for all cells to be at version v, but for there to be messages in flight that
    would cause one cell to update to version v+1?... Yes.

    Ok, so we broadcast up to the root:
    - version, count=1, sent, received
    and the collectors reduce to:
    if( versionA < versionB ) {
       (versionB, countB, sentB, receivedB)
    else if( versionA > versionB ){
       (versionA, countA, sentA, receivedA)
    else
       (versionA, countA+countB, sendA+sentB, receivedA+receivedB)

    termination is detected at the root when:
       count==len(cells) && sent==received



    ]]></Documentation>
	
		<MetaData>
			"location.dimension" : 2
		</MetaData>

  <SharedCode>
  <![CDATA[
  int32_t abs_diff(int32_t a, int32_t b)
  {
    return (a>b) ? a-b : b-a;
  }
  ]]>
  </SharedCode>

	<Properties>
      <Scalar type="uint32_t" name="maxTime" default="65" />
    </Properties>

    <MessageTypes>
      <MessageType id="__init__">
				<!-- This doesn't have any properties -->
      </MessageType>

			<MessageType id="share">
        <Message>
         <Scalar type="uint32_t" name="version" />
			   <Scalar type="uint8_t" name="colour" />
         <Scalar type="int8_t" name="temperature" />
        </Message>
			</MessageType>

      <MessageType id="termination">
        <Message>
          <Scalar type="uint32_t" name="version" /><!-- Which version this is talking about -->
          <Scalar type="uint32_t" name="count" /><!-- Number of cells at this version -->
          <Scalar type="uint32_t" name="sent" /><!-- Number of sends performed at this version -->
          <Scalar type="uint32_t" name="received" /><!-- Number of receives performed at this version -->
          <Scalar type="uint8_t" name="index" /><!-- Index to tell parent which child this is from -->
        </Message> 
			</MessageType>
    </MessageTypes>

    <DeviceTypes>

      <DeviceType id="cell">
        <Properties>
          <Scalar type="int8_t" name="initial" />
          
          <Scalar type="int8_t" name="boundary" />
          <Scalar type="uint8_t" name="colour"/>
          <Scalar type="uint8_t" name="termination_index"/> <!-- index to give to termination parent -->

          <Scalar type="uint8_t" name="neighbours"/>
        </Properties>

        <State>
          <Scalar name="currVersion" type="uint32_t" />

          <Scalar name="nextVersion" type="uint32_t" />
          <Scalar name="sent" type="uint32_t" />
          <Scalar name="received" type="uint32_t" />

          <Scalar name="currHeat" type="int8_t" />
          <Scalar name="nextHeat" type="int8_t" />
          
          <Array name="nhood" type="int8_t" length="4" />

          <Scalar name="dirty" type="int8_t" /> <!-- The state has updated, but not yet send upwards for termination -->
        </State>

		<ReadyToSend><![CDATA[
		*readyToSend		= 0;
		if( abs_diff(deviceState->currHeat,deviceState->nextHeat) > 3  || deviceState->currVersion < deviceState->nextVersion ){
       *readyToSend=RTS_FLAG_share_out;
    }else if(deviceState->dirty){
      *readyToSend=RTS_FLAG_termination_out;
    }
		]]></ReadyToSend>

		<InputPin name="__init__" messageTypeId="__init__">
		  <OnReceive><![CDATA[
      deviceState->currHeat=0;
      if(deviceProperties->boundary){
         deviceState->nextHeat=deviceProperties->initial;
      }

      deviceState->currVersion=0;

      deviceState->nextVersion=1;
      deviceState->sent=0;
      deviceState->received=0;

      deviceState->dirty=true;
		  ]]></OnReceive>
		</InputPin>

		<InputPin name="share_in" messageTypeId="share">
		  <OnReceive><![CDATA[
      if( !deviceProperties->boundary ){
        deviceState->nhood[message->colour] = message->temperature;

        int32_t sum=0;
        for(unsigned i=0; i<4; i++){
          sum += deviceState->nhood[i];
        }

        deviceState->nextHeat = (sum+2)/4;

      }
      if(deviceState->nextVersion < message->version){
          deviceState->nextVersion=message->version;
          deviceState->received=0;
          deviceState->sent=0;
      }
      if(deviceState->nextVersion == message->version){
        deviceState->received++;        
      }

      deviceState->dirty=true;
		  ]]></OnReceive>
		</InputPin>

		<OutputPin name="share_out" messageTypeId="share">
		  <OnSend><![CDATA[
			assert(abs_diff(deviceState->currHeat,deviceState->nextHeat) > 3 || deviceState->currVersion != deviceState->nextVersion );
      
      if( abs_diff(deviceState->currHeat,deviceState->nextHeat) > 3 ){
        deviceState->currHeat=deviceState->nextHeat;      
        deviceState->nextVersion+=1;
        deviceState->sent=0;
        deviceState->received=0;
      }

      assert(deviceState->sent==0);

      deviceState->currVersion=deviceState->nextVersion;
      deviceState->sent=deviceProperties->neighbours;

      message->version=deviceState->currVersion;
      message->colour=deviceProperties->colour;
      message->temperature=deviceState->nextHeat;



      deviceState->dirty=true;
		  ]]></OnSend>
    </OutputPin>

    <OutputPin name="termination_out" messageTypeId="termination">
		  <OnSend><![CDATA[
			assert(deviceState->dirty);
      assert(abs_diff(deviceState->currHeat,deviceState->nextHeat) <= 3);
      
      assert(deviceState->currVersion <= deviceState->currVersion);
      deviceState->currVersion = deviceState->nextVersion;
      
      message->version=deviceState->currVersion;
      message->sent=deviceState->sent;
      message->received=deviceState->received;
      message->count=1;
      message->index=deviceProperties->termination_index;

      deviceState->currHeat=deviceState->nextHeat;      

      deviceState->dirty=false;
		  ]]></OnSend>
		</OutputPin>
	</DeviceType>

  <DeviceType id="merger">
    <Properties>
      <Scalar type="uint8_t" name="degree" />
      <Scalar type="uint8_t" name="termination_index" />
      
    </Properties>

    <State>
      <Scalar name="version" type="uint32_t" />
      
      <Array name="count" type="uint32_t" length="4" />
      <Array name="sent" type="uint32_t" length="4" />
      <Array name="received" type="uint32_t" length="4" />

      <Scalar name="dirty" type="uint8_t" />
    </State>

    <ReadyToSend><![CDATA[
      *readyToSend = deviceState->dirty ? RTS_FLAG_termination_out : 0;
    ]]></ReadyToSend>

    <InputPin name="__init__" messageTypeId="__init__">
    <OnReceive><![CDATA[
      // Accept all defaults

      // Check the degree property doesn't exceed the array size
      assert( deviceProperties->degree <= sizeof(deviceState->count)/sizeof(deviceState->count[0]) );
    ]]></OnReceive>
    </InputPin>

    <InputPin name="termination_in" messageTypeId="termination">
      <OnReceive><![CDATA[
    
    if(deviceState->version < message->version){
      deviceState->version=message->version;
      for(unsigned i=0; i<deviceProperties->degree; i++){
        deviceState->sent[i]=0;
        deviceState->received[i]=0;
        deviceState->count[i]=0;
      }
    }
    if(deviceState->version == message->version){
      unsigned index=message->index;
      assert(index<deviceProperties->degree);
      
      deviceState->count[index]=message->count;
      deviceState->received[index]=message->received;
      deviceState->sent[index]=message->sent;

      deviceState->dirty=true;
    }

    ]]></OnReceive>
    </InputPin>

    <OutputPin name="termination_out" messageTypeId="termination">
    <OnSend><![CDATA[
    assert(deviceState->dirty);
    
    // TODO: this could be optimised to only send down when the total count
    // matches the sum of all cells recursively above this on the tree.

    message->version=deviceState->version;
    message->count=0;
    message->sent=0;
    message->received=0;
    message->index=deviceProperties->termination_index;

    for(unsigned i=0; i<deviceProperties->degree; i++){
      message->count+=deviceState->count[i];
      message->sent+=deviceState->sent[i];
      message->received+=deviceState->received[i];
    }

    deviceState->dirty=false;
    ]]></OnSend>
    </OutputPin>
  </DeviceType>

  <DeviceType id="root">
    <Properties>
      <Scalar type="uint32_t" name="totalCells" />
    </Properties>

    <ReadyToSend><![CDATA[
      *readyToSend = 0;
    ]]></ReadyToSend>

    <InputPin name="termination_in" messageTypeId="termination">
      <OnReceive><![CDATA[
      assert(message->index==0); // Root doesn't do any merging

      handler_log(2, "version=%u, count=%u (of %u), sent=%u, received=%u", message->version, message->count, deviceProperties->totalCells, message->sent, message->received);

      if(message->count==deviceProperties->totalCells && message->sent==message->received){
        handler_exit(0);
      }
      ]]></OnReceive>
    </InputPin>

  </DeviceType>



    </DeviceTypes>
  </GraphType>
</Graphs>
