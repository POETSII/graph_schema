<?xml version='1.0' encoding='ASCII'?>
<Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v3">
  <GraphType id="relaxation_heat">
    <Documentation>
		Supposed to broadly match spinnaker experiments.

		Each cell has a current heat h, and four neighbours n[0..3]. When an update
		arrives the cell will store it in n[x], the calculate h'=sum(n)/4. If
		|h' - h| &gt; 3 then it will update its neighbours.

		This is designed not to use edge properties, so it uses a strictly cartesian
		grid and colours the devices:

       0  1  2  3  4  5  6
     +--------------------
   0 | 0  1  3  2  0  1  3
   1 | 0  2  3  1  0  2  3
   2 | 3  2  0  1  3  2  0
   3 | 3  1  0  2  3  1  0
   4 | 0  1  3  2  0  1  3
   5 | 0  2  3  1  0  2  3
   6 | 3  2  0  1  3  2  0

		Each device broadcasts their colour with their heat, so the heat will always
		get routed to a unique position in the array.


    </Documentation>
    <Types/>
    <Properties>
      <Scalar name="maxTime" type="uint32_t" default="65"/>
    </Properties>
    <MetaData>"location.dimension": 2</MetaData>
    <SharedCode><![CDATA[
  
  int32_t abs_diff(int32_t a, int32_t b)
  {
    return (a>b) ? a-b : b-a;
  }
  
  ]]></SharedCode>
    <MessageTypes>
      <MessageType id="share">
        <Message>
          <Scalar name="version" type="uint32_t"/>
          <Scalar name="colour" type="uint8_t"/>
          <Scalar name="temperature" type="uint8_t"/>
        </Message>
      </MessageType>
    </MessageTypes>
    <DeviceTypes>
      <DeviceType id="cell">
        <Properties>
          <Scalar name="initial" type="int32_t" default="127"/>
          <Scalar name="boundary" type="int32_t"/>
          <Scalar name="colour" type="uint8_t"/>
        </Properties>
        <State>
          <Scalar name="version" type="uint32_t"/>
          <Scalar name="currHeat" type="uint8_t"/>
          <Scalar name="nextHeat" type="uint8_t"/>
          <Array name="nhood" length="4" type="uint8_t"/>
        </State>
        <OnInit><![CDATA[
		  deviceState->version=0;
      for(unsigned i=0; i<4; i++){
         deviceState->nhood[i]=127;
      }

      deviceState->currHeat=deviceProperties->initial;
      deviceState->nextHeat=deviceState->currHeat+128; // Trigger a share
		  ]]></OnInit>
        <InputPin name="share_in" messageTypeId="share">
          <OnReceive><![CDATA[
      if( !deviceProperties->boundary ){
        deviceState->nhood[message->colour] = message->temperature;

        int32_t sum=0;
        for(unsigned i=0; i<4; i++){
          sum += deviceState->nhood[i];
        }

        deviceState->nextHeat = sum/4;
      }
		  ]]></OnReceive>
        </InputPin>
        <OutputPin name="share_out" messageTypeId="share">
          <OnSend><![CDATA[
			assert(deviceState->nextHeat != deviceState->currHeat);
      ++deviceState->version;

      message->version=deviceState->version;
      message->colour=deviceProperties->colour;
      message->temperature=deviceState->nextHeat;

      deviceState->currHeat=deviceState->nextHeat;
		  ]]></OnSend>
        </OutputPin>
        <ReadyToSend><![CDATA[
		*readyToSend		= 0;
		if( abs_diff(deviceState->currHeat,deviceState->nextHeat) > 3 ){
       *readyToSend=RTS_FLAG_share_out;
    }
		]]></ReadyToSend>
      </DeviceType>
    </DeviceTypes>
  </GraphType>
</Graphs>
