<?xml version="1.0"?>
<Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v2">
  <GraphType id="airfoil">
    <!-- This is supposed to implement the method from [lubachevsky-87-asynchronous-ising-spin-models]:
	 "Efficient Parallel Simulations of Asynchronous Cellular Arrays", 1987, Boris D. Lubachevsky -->

    <MetaData>
      "nativeDimension":2
    </MetaData>

    <Properties>
      <Scalar type="float" name="gam" />
			<Scalar type="float" name="gm1" />
			<Scalar type="float" name="cfl" />
			<Scalar type="float" name="eps" />
			<Scalar type="float" name="mach" />
			<Scalar type="float" name="alpha" />
			<Array type="float" name="qinf" length="4" />
    </Properties>

    <SharedCode><![CDATA[

    ]]></SharedCode>

    <MessageTypes>
      <MessageType id="__init__">
				<!-- This doesn't have any properties -->
      </MessageType>

      <MessageType id="__print__">
				<!-- This doesn't have any properties -->
      </MessageType>

      <MessageType id="node_pos">
				<Message>
					<Array type="float" name="x" length="2" />
				</Message>
      </MessageType>

			<MessageType id="node_pos_ack" />

			<MessageType id="cell_q_adt">
				<Message>
					<Array type="float" name="q" length="4" />
					<Scalar type="float" name="adt" />
				</Message>
      </MessageType>

			<MessageType id="res_inc">
				<Message>
					<Array type="float" name="res" length="4" />
				</Message>
      </MessageType>


			<MessageType id="rms_inc">
				<Message>
					<Scalar type="float" name="rms" />
				</Message>
      </MessageType>

			<MessageType id="rms_inc_ack" />

    </MessageTypes>

    <DeviceTypes>
      <DeviceType id="node">
				<Properties>
					<Array type="float" name="x" length="2" />
					<Scalar type="uint32_t" name="fanout">
						<Documentation>
							The number of people who will receive
							and acknowledge each x broadcast.
						</Documentation>
					</Scalar>
				</Properties>

				<State>
					<Scalar name="acks_pending" type="uint8_t">
						<Documentation>
							Number of listeners who have not yet acknowledged.
						</Documentation>
					</Scalar>
				</State>

				<ReadyToSend><![CDATA[
				*readyToSend = deviceState->acks_pending==0 ? RTS_FLAG_pos_out : 0;
				]]></ReadyToSend>

				<OutputPin name="pos_out" messageTypeId="node_pos">
					<OnSend><![CDATA[
						message->x[0]=deviceProperties->x[0];
						message->x[1]=deviceProperties->x[1];
						deviceState->acks_pending=deviceProperties->fanout;
					]]></OnSend>
				</OutputPin>

				<InputPin name="ack_in" messageTypeId="node_pos_ack">
					<OnReceive><![CDATA[
					assert(deviceState->acks_pending>0);
					deviceState->acks_pending--;
					]]></OnReceive>
				</InputPin>

      </DeviceType>

      <DeviceType id="cell">
				<SharedCode><![CDATA[
				enum Phase{
					Phase_AdtCalc = 0 , // Collecting node positions
					Phase_Update // collecting res from edges/bedges
				};

				template<class TGP, class TDS>
				void adt_calc(
					const TGP *graphProperties, // For the globals
					TDS *deviceState, // For the "members"
					float x1[2],
					float x2[2],
					float x3[2],
					float x4[4]
				);

				template<class TGP, class TDS>
				void update(
					const TGP *graphProperties, // For the globals
					TDS *deviceState // For the "members"
				);

				]]></SharedCode>

				<Properties>
					<!--<Array type="float" name="x" length="2" />
					<Scalar type="uint32_t" name="fanout">
						<Documentation>
							The number of people who will receive
							and acknowledge each x broadcast.
						</Documentation>
					</Scalar>-->
				</Properties>

				<State>
					<!-- Intrinsic state of the cell -->
					<Array name="q" type="float" length="4" />
					<Array name="qold" type="float" length="4" />
					<Array name="res" type="float" length="4" />
					<Scalar name="adt" type="float" />

					<!-- Which phase we are in: 0==adt, 1==update -->
					<Scalar name="phase" type="uint32_t" />

					<!-- receive x positions from four nodes defining edge corners -->
					<Array name="x_buff" type="float" length="8" />
					<Scalar name="x_buff_got" type="uint32_t" />
					<Scalar name="x_ack_pending" type="uint32_t" /> <!-- Boolean. Set once we have used the x, and want the next one -->

					<Scalar name="res_pending" type="uint32_t" /> <!-- Count down to zero as we receive res increments -->

					<Scalar name="rms_inc_ack_pending" type="uint32_t" /> <!-- Boolean. Set if we have sent an rms_inc, but it is not acked -->


				</State>

				<ReadyToSend><![CDATA[
				*readyToSend=0;
				if(deviceState->phase==Phase_AdtCalc){
					if(deviceState->x_buff_got==4){
						*readyToSend |= RTS_FLAG_adt_calc;
					}
				}else if(deviceState->phase==Phase_Update){
					if(deviceState->res_pending==0){
						*readyToSend |= RTS_FLAG_update;
					}
				}

				if(deviceState->x_ack_pending){ // Lower priority
					*readyToSend |= RTS_FLAG_pos_ack_out;
				}
				]]></ReadyToSend>

				<InputPin name="pos_in" messageTypeId="node_pos">
					<Properties>
						<Scalar type="uint8_t" name="index" />
					</Properties>
					<OnReceive><![CDATA[
						assert(deviceState->x_buff_got<4);
						assert(!deviceState->x_ack_pending);
						uint32_t offset=2*edgeProperties->index;
						deviceState->x_buff[offset+0]=message->x[0];
						deviceState->x_buff[offset+1]=message->x[1];
						deviceState->x_buff_got++;
					]]></OnReceive>
				</InputPin>

				<OutputPin name="adt_calc" messageTypeId="cell_q_adt">
					<OnSend><![CDATA[
					assert(deviceState->phase==Phase_AdtCalc);
					assert(deviceState->x_buff_got==4);
					assert(deviceState->x_ack_pending==0);

					adt_calc(
						graphProperties, // For the globals
						deviceState, // For the "members"
						deviceState->x_buff+0,
						deviceState->x_buff+2,
						deviceState->x_buff+4,
						deviceState->x_buff+6
					);

					// Send q and adt to the four edge/bedge
					for(unsigned j=0; j<4; j++){
						message->q[j]=deviceState->q[j];
					}
					message->adt=deviceState->adt;

					deviceState->x_ack_pending=1; // Might as well request the next x (Note: the whole x movement is pointless)
					deviceState->phase=Phase_Update;
					deviceState->res_pending=4; // need to get res increments from surrounding 4 edge/bedges
					]]></OnSend>
				</OutputPin>

				<OutputPin name="pos_ack_out" messageTypeId="node_pos_ack">
					<!-- Lower priority than adt_calc_out -->
					<OnSend><![CDATA[
					assert(deviceState->x_buff_got==4);
					assert(deviceState->x_ack_pending);
					deviceState->x_buff_got=0;
					deviceState->x_ack_pending=0;
					]]></OnSend>
				</OutputPin>

				<InputPin name="res_inc_in" messageTypeId="res_inc">
					<OnReceive><![CDATA[
					assert(deviceState->phase==Phase_Update);
					assert(deviceState->res_pending>0);
					for(int j=0; j<4; j++){
						deviceState->res[j] += message->res[j];
					}
					deviceState->res_pending--;
					]]></OnReceive>
				</InputPin>

				<OutputPin name="update" messageTypeId="rms_inc">
					<OnSend><![CDATA[
					assert(deviceState->phase==Phase_Update);
					assert(deviceState->res_pending==0);
					assert(!deviceState->rms_inc_ack_pending); // Don't send this update if a previous rms has not acked yet

					update(
						graphProperties,
						deviceState
					);

					deviceState->phase=Phase_AdtCalc;
					deviceState->rms_inc_ack_pending=1;
					]]></OnSend>
				</OutputPin>

				<InputPin name="rms_ack" messageTypeId="rms_inc_ack">
					<OnReceive><![CDATA[
					assert(rms_inc_ack_pending);
					deviceState->rms_inc_ack_pending=0;
					]]></OnReceive>
				</InputPin>
      </DeviceType>

			<DeviceType id="edge">
				<State>
					<!-- receive x positions from four nodes defining edge corners -->
					<Array name="x_buff" type="float" length="8" />
					<Scalar name="x_buff_got" type="uint32_t" />
					<Scalar name="x_ack_pending" type="uint32_t" /> <!-- Boolean. Set once we have used the x, and want the next one -->

					<Array name="q_buff" type="float" length="8" />   <!-- Pair of 4-tuples --> 
					<Array name="adt_buff" type="float" length="2" /> <!-- two scalars -->
					<Scalar name="q_adt_buff_got" type="uint32_t" />

					<!-- buffer needed due to the two-way send -->
					<Array name="res2_buff" type="float" length="4" /> 
					<Scalar name="res2_pending" type="uint32_t" /> <!-- Boolean. Set if we need to complete the two-way send -->
				</State>

				<SharedCode><![CDATA[
				template<class TGP>
				void res_calc(
						const TGP *graphProperties,
						const float x1[2],
						const float x2[2],
						const float q1[4],
						const float q2[4],
						float adt1,
						float adt2,
						float res1[4],
						float res2[4]
					);
				]]></SharedCode>

				<ReadyToSend><![CDATA[
				*readyToSend=0;
				if(deviceState->res2_pending){
					*readyToSend |= RTS_FLAG_res_calc_res2;
				}
				if(deviceState->x_ack_pending){
					*readyToSend |= RTS_FLAG_pos_ack_out;
				}
				if( deviceState->q_adt_buff_got==2
						&& deviceState->x_buff_got==2
						&& !deviceState->x_ack_pending
						&& !deviceState->res2_pending
				){
					*readyToSend |= RTS_FLAG_res_calc;
				}
				]]></ReadyToSend>

				<InputPin name="pos_in" messageTypeId="node_pos">
					<Properties>
						<Scalar type="uint8_t" name="index" />
					</Properties>
					<OnReceive><![CDATA[
						assert(deviceState->x_buff_got<4);
						assert(!deviceState->x_ack_pending);
						uint32_t offset=2*edgeProperties->index;
						deviceState->x_buff[offset+0]=message->x[0];
						deviceState->x_buff[offset+1]=message->x[1];
						deviceState->x_buff_got++;
					]]></OnReceive>
				</InputPin>

				<InputPin name="q_adt_in" messageTypeId="cell_q_adt">
					<Properties>
						<Scalar type="uint8_t" name="index" />
					</Properties>
					<OnReceive><![CDATA[
						assert(deviceState->q_adt_buff_got<2);
						uint32_t offset=4*edgeProperties->index;
						for(unsigned i=0; i<4; i++){
							deviceState->q_buff[offset+i]=message->q[i];
						}
						deviceState->adt_buff[edgeProperties->index]=message->adt;
						deviceState->q_adt_buff_got++;
					]]></OnReceive>
				</InputPin>

				<OutputPin name="res_calc" messageTypeId="res_inc">
					<OnSend><![CDATA[
						assert(deviceState->q_adt_buff_got==2);
						assert(deviceState->x_buff_got==2);
						assert(!deviceState->x_ack_pending);
						assert(!deviceState->res2_pending);

						res_calc(
							graphProperties,
							deviceState->x_buff+0,
							deviceState->x_buff+2,
							deviceState->q_buff+0,
							deviceState->q_buff+4,
							deviceState->adt_buff[0],
							deviceState->adt_buff[1],
							message->res,	// First half of the send
							deviceState->res2_buff // Will do second half later
						);

						deviceState->q_adt_buff_got=0;
						deviceState->x_buff_got=0;
						deviceState->x_ack_pending=1;
						deviceState->res2_pending=1;
					]]></OnSend>
				</OutputPin>

				<OutputPin name="res_calc_res2" messageTypeId="res_inc">
					<OnSend><![CDATA[
						// Second half of the send
						assert(deviceState->res2_pending);

						for(int j=0; j<4; j++){
							message->res[j]=deviceState->res2_buff[j];
						}

						deviceState->res2_pending=0;
					]]></OnSend>
				</OutputPin>

				<OutputPin name="pos_ack_out" messageTypeId="node_pos_ack">
					<!-- Lower priority than res_calc* outputs -->
					<OnSend><![CDATA[
					assert(deviceState->x_buff_got==4);
					assert(deviceState->x_ack_pending);
					deviceState->x_buff_got=0;
					deviceState->x_ack_pending=0;
					]]></OnSend>
				</OutputPin>
			</DeviceType>
    </DeviceTypes>
  </GraphType>
</Graphs>
