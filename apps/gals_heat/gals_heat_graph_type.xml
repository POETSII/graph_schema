<?xml version="1.0"?>
<Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v2" formatMinorVersion="1">
  <GraphType id="gals_heat" >
	<Documentation><![CDATA[
    Locally synchronous heat.

	 Each cell i has a time t, and all cells start at t=0.
	 Initially each cell knows its own state, but not its
	 neighbours, so all cells want to broadcast their state and move to t=1.
	 However, there is no ordering on the broadcasts, so the
	 order they achieve it in is going to be random.

         As the messages fly we have a number of situations:
         - t=0, no messages received    : wants to send t=0
	 - t=0, some messages received  : wants to send t=0
	 - t=0, all messages received   : wants to send t=1 (could also send t=2, but has to do t=1 first)
	 - t=1, no messaged received    : blocked
	 - t=1, some messages received  : blocked
	 - t=1, all messages recieved   : wants to send t=2

         In order to progress to t=2 (i.e. send) a cell must have received t=1 from all
         neighbours. However, while waiting for t=1 from one neighbour, it might also
	 receive t=2 from another neighbour, which it will need to repemeber for next
	 time. It is not possible to recieve anything with t=3, as no neighbour can get
	 there without receiving our t=2 (which we haven't sent yet).

         So at a given time t we need to deal with messages for both t=1 and t=2,
         and essentially need two copies. When we advance, the t+1 copy becomes
	 the t version and t+1 is empty.
    ]]></Documentation>
	
		<MetaData>
			"location.dimension" : 2
		</MetaData>

		<Types>
			<TypeDef id="update_t">
				<Tuple name="_">
					<Scalar type="uint32_t" name="t" />
					<Scalar type="float" name="v" />
				</Tuple>
			</TypeDef>
		</Types>

	<Properties>
      <Scalar type="uint32_t" name="maxTime" default="65" />
			<Scalar type="uint32_t" name="exportDeltaMask" default="15">
				<Documentation><![CDATA[
				Controls the rate at which values are exported. Interior cells will
				export when (t & exportDeltaMask)==0
				]]></Documentation>
			</Scalar>
    </Properties>

    <SharedCode><![CDATA[
    #include <cmath>
    ]]></SharedCode>

    <MessageTypes>
      <MessageType id="__init__">
				<!-- This doesn't have any properties -->
      </MessageType>

			<MessageType id="finished">
			</MessageType>

      <MessageType id="update">
				<Message>
					<Scalar type="update_t" name="v" />
				</Message>
      </MessageType>
    </MessageTypes>

    <DeviceTypes>




      <DeviceType id="dirichlet_variable">
		<Properties>
			<Scalar type="int32_t" name="dt" default="1" />

		  <Scalar type="float" name="amplitude" />
		  <Scalar type="float" name="phase" />
		  <Scalar type="float" name="frequency" />
		  <Scalar type="float" name="bias" />

		  <Scalar type="uint32_t" name="neighbours" /> <!-- We need to know the neighbour count in order to sync -->
		</Properties>

		<State>
		  <Scalar type="float" name="v" />
		  <Scalar type="uint32_t" name="t" />

		  <Scalar type="uint32_t" name="cs" />
		  <Scalar type="uint32_t" name="ns" />
		</State>

		<ReadyToSend><![CDATA[
		*readyToSend		= 0;
		if(deviceState->t < graphProperties->maxTime){
			if(deviceState->cs==deviceProperties->neighbours){
				*readyToSend = RTS_FLAG_out;
			}
		}else if(deviceState->t == graphProperties->maxTime){
			*readyToSend=RTS_FLAG_finished;
		}
		]]></ReadyToSend>

		<InputPin name="__init__" messageTypeId="__init__">
		  <OnReceive><![CDATA[
		  deviceState->t=0;
		  deviceState->cs=deviceProperties->neighbours;
		  deviceState->ns=0;

		  deviceState->v=deviceProperties->bias + deviceProperties->amplitude
			     * sin(deviceProperties->phase + deviceProperties->frequency * deviceState->t);
		  ]]></OnReceive>
		</InputPin>

		<InputPin name="__print__" messageTypeId="__init__">
		  <OnReceive><![CDATA[
		  handler_log(0, "t = %d, v=%8g (seenNow=%d, seenNext=%d)", deviceState->t, deviceState->v, deviceState->cs, deviceState->ns);
		  ]]></OnReceive>
		</InputPin>

		<InputPin name="in" messageTypeId="update">
		  <OnReceive><![CDATA[
			handler_log(3, "m=(t=%d,v=%.4f) tNow=%d, sNow=%d, aNow=%.4f, sNext=%d, aNext=%f", message->v.t, message->v.v, deviceState->t, deviceState->cs, deviceState->ns);
		  
			if(message->v.t==deviceState->t){
				deviceState->cs++;
		  }else{
				deviceState->ns++;

				assert(
					(deviceState->t + deviceProperties->dt == message->v.t) // Either it is one step ahead
					||
					(deviceState->t == graphProperties->maxTime+1)  // Or we are idle and don't care
				);
		  }
		  ]]></OnReceive>
		</InputPin>

		<OutputPin name="out" messageTypeId="update">
		  <OnSend><![CDATA[
			assert(deviceState->t < graphProperties->maxTime);
			assert(deviceState->cs==deviceProperties->neighbours);

			deviceState->v=deviceProperties->bias + deviceProperties->amplitude
					* sin(deviceProperties->phase + deviceProperties->frequency * deviceState->t);

			deviceState->t = deviceState->t + deviceProperties->dt;
			deviceState->cs = deviceState->ns;
			deviceState->ns = 0;

			message->v.t = deviceState->t;
			message->v.v = deviceState->v;
		  ]]></OnSend>
		</OutputPin>

		<OutputPin name="finished" messageTypeId="finished">
			<OnSend><![CDATA[
			assert(deviceState->t==graphProperties->maxTime);
			deviceState->t++; // We advance beyond the end of time and go idle
			// And send an empty pulse to exit node
			]]></OnSend>
		</OutputPin>


	</DeviceType>

      <DeviceType id="cell">
		<!-- This is a common-or-garden 2d cell, with no boundary stuff -->
		<Properties>
		  <Scalar type="float" name="iv" />
		  <Scalar type="uint32_t" name="nhood" />
		  <Scalar type="float" name="wSelf" />
		  <Scalar type="uint32_t" name="dt" default="1" />
		</Properties>

		<State>
		  <Scalar type="float" name="v" />
		  <Scalar type="uint32_t" name="t" />

		  <Scalar type="float" name="ca" /> <!-- w_self * s_self + sum( w_o * s_o for o in seenNow)  -->
		  <Scalar type="uint32_t" name="cs" />

		  <Scalar type="float" name="na" /> <!-- sum(w_o * s_o for o in seenNext) -->
		  <Scalar type="uint32_t" name="ns" />
		</State>

		<ReadyToSend><![CDATA[
		*readyToSend = 0;
		if(deviceState->t < graphProperties->maxTime){
			if(deviceState->cs==deviceProperties->nhood){
				*readyToSend = RTS_FLAG_out;
			}
		}else if(deviceState->t == graphProperties->maxTime){
			*readyToSend = RTS_FLAG_finished;
		}
		]]></ReadyToSend>


		<InputPin name="__init__" messageTypeId="__init__">
		  <OnReceive><![CDATA[
		  deviceState->v=0;
		  deviceState->t=0;
		  deviceState->ca = deviceProperties->iv;
		  deviceState->cs = deviceProperties->nhood;

		  deviceState->ns=0;
		  deviceState->na=0;

		  handler_log(3, "value = %f", deviceState->v);
		  ]]></OnReceive>
		</InputPin>

		<InputPin name="__print__" messageTypeId="__init__">
		  <OnReceive><![CDATA[
		  handler_log(0, "t = %d, v=%8g (seenNow=%d, seenNext=%d)", deviceState->t, deviceState->v, deviceState->cs, deviceState->ns);
		  ]]></OnReceive>
		</InputPin>


		<InputPin name="in" messageTypeId="update">
			<Properties>
				<Scalar type="float" name="w" />
			</Properties>

		  <OnReceive><![CDATA[
			handler_log(3, "m=(t=%d,v=%.4f) tNow=%d, sNow=%d, aNow=%.4f, sNext=%d, aNext=%f", message->v.t, message->v.v, deviceState->t, deviceState->cs, deviceState->ca, deviceState->ns, deviceState->na);
		  if(message->v.t==deviceState->t){
				deviceState->ca += edgeProperties->w * message->v.v;
				deviceState->cs++;
		  }else{
				deviceState->na += edgeProperties->w * message->v.v;
				deviceState->ns++;

				assert(
					(deviceState->t + deviceProperties->dt == message->v.t) // Either it is one step ahead
					||
					(deviceState->t == graphProperties->maxTime+1)  // Or we are idle and don't care
				);
			}
		]]></OnReceive>
		</InputPin>

		<OutputPin name="finished" messageTypeId="finished">
			<OnSend><![CDATA[
			deviceState->t++; // We advance beyond the end of time and go idle
			// And send an empty pulse to exit node
			]]></OnSend>
		</OutputPin>

		<OutputPin name="out" messageTypeId="update">
		  <OnSend><![CDATA[

		  handler_log(3, "tNow=%d, sNow=%d, aNow=%.4f, sNext=%d, aNext=%f", deviceState->t, deviceState->cs, deviceState->ca, deviceState->ns, deviceState->na);

			assert(deviceState->cs == deviceProperties->nhood);

			deviceState->t += deviceProperties->dt;
			deviceState->v=deviceState->ca;

			// TODO : move this out of the send handler into compute
			if( (deviceState->t & graphProperties->exportDeltaMask)==0 ){
				handler_export_key_value(0, 0x800000ul+(uint32_t)(int32_t)(deviceState->v*65536));
			}

			deviceState->ca = deviceProperties->wSelf * deviceState->v + deviceState->na;
			deviceState->cs = deviceState->ns;

			deviceState->na=0;
			deviceState->ns=0;

			message->v.t=deviceState->t;
			message->v.v=deviceState->ca;

			// It is possible that all our neighbours are ahead and have broadcast, so
			// we could immediately be ready to go.
		  ]]></OnSend>
		</OutputPin>
		</DeviceType>


		<DeviceType id="exit_node">
			<Properties>
				<Scalar name="fanin" type="uint32_t" />
			</Properties>
			
			<State>
				<Scalar name="done" type="uint32_t" />
			</State>
			
			<ReadyToSend><![CDATA[
			*readyToSend=0;
			]]></ReadyToSend>

			<InputPin name="done" messageTypeId="finished">
				<OnReceive><![CDATA[
				deviceState->done++;
				if(deviceState->done == deviceProperties->fanin){
					handler_exit(0);
				}
				]]></OnReceive>
			</InputPin>
		</DeviceType>

    </DeviceTypes>
  </GraphType>
</Graphs>
