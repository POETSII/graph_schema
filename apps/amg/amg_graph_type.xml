<?xml version='1.0' encoding='ASCII'?>
<Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v3">
  <GraphType id="amg">
    <Types/>
    <Properties>
      <Scalar name="residualTol" type="float">
        <Documentation>The tolerance for the maximum absolute residual.</Documentation>
      </Scalar>
    </Properties>
    <SharedCode><![CDATA[
        #include <cmath>
        #include <cfloat>
        #include <algorithm>

        #ifdef POETS_LEGACY_HAS_HANDLER_EXIT
        #define _do_handler_exit(code) handler_exit(code)
        #else
        #define _do_handler_exit(code) ((void)0)
        #endif

        #define fake_handler_exit(code) \
        { \
            if((code)==0){ \
                handler_log(0, "_HANDLER_EXIT_SUCCESS_9be65737_"); \
            }else{ \
                handler_log(0, "_HANDLER_EXIT_FAIL_9be65737_"); \
            } \
            _do_handler_exit(code); \
        }

      enum State{
            State_Idle,
            State_PreSmooth,
            State_PreResidual,
            State_Coarse,     
            State_PostSmooth
        };
]]></SharedCode>
    <MessageTypes>
      <MessageType id="linear_problem">
        <Documentation>Provides a problem $A x = b$, with $A$ a known matrix encoded in the edge weights.</Documentation>
        <Message>
          <Scalar name="x" type="float">
            <Documentation>Guess at solution. Part of $x=x_(1)$.</Documentation>
          </Scalar>
          <Scalar name="b" type="float">
            <Documentation>Value to solve for. Part of $b=b_(1)$.</Documentation>
          </Scalar>
        </Message>
      </MessageType>
      <MessageType id="linear_solution">
        <Documentation>Provides a solution to $A x = b$.</Documentation>
        <Message>
          <Scalar name="x" type="float">
            <Documentation>Solution. Part of $x=x_(1)$.</Documentation>
          </Scalar>
          <Scalar name="r" type="float">
            <Documentation>Global residual of the solution. $r = max(A x - b)$.</Documentation>
          </Scalar>
          <Scalar name="i" type="int32_t">
            <Documentation>Number of iterations used.</Documentation>
          </Scalar>
        </Message>
      </MessageType>
      <MessageType id="jacobi_exchange">
        <Documentation>Shares a current solution to $A_(i) x_(i) = b_(i)$.</Documentation>
        <Message>
          <Scalar name="x" type="float">
            <Documentation>Solution. Part of $x=x_(i)$.</Documentation>
          </Scalar>
          <Scalar name="tag" type="uint32_t">
            <Documentation>Used to indicate what stage of the algorithm this is comging from.</Documentation>
          </Scalar>
        </Message>
      </MessageType>
      <MessageType id="fine_to_coarse">
        <Documentation>Messages being sent up the grid, in order to solve $A_(i) x_(i) = b_(i)$, where $A_(i)$ is some restricted
            version of $A_(i) = R_(i) A_(i-1)$, and $b_(i)$ is a restricted version of the residual $R_(i) (A_(i-1) x_(i-1) - b_(i-1))$.

            $max(r)$ is the _local_ maximum residual, i.e. it is a part of $max( A_0 x_0 - b_0) on the
            finest level, but only covers the parts of the cone the device is connected to.
            </Documentation>
        <Message>
          <Scalar name="b" type="float">
            <Documentation>Value to solve for. Part of b_(i-1)</Documentation>
          </Scalar>
          <Scalar name="max_r" type="float">
            <Documentation>Max residual of all finer nodes (though not for whole network)</Documentation>
          </Scalar>
        </Message>
      </MessageType>
      <MessageType id="coarse_to_fine">
        <Documentation>Corrections sent down the grid. These will be prolonged back onto the finer
        solution, so $x_(i) = x_(i) + P_(i+1) x_(i+1)$.
        $max(r)$ is the _global_ maximum residual for the original version of x at the finest level of the grid.
        </Documentation>
        <Message>
          <Scalar name="x" type="float">
            <Documentation>Best guess for $x_(i+1)$</Documentation>
          </Scalar>
          <Scalar name="max_r" type="float">
            <Documentation>Max residual of all nodes (for the whole network)</Documentation>
          </Scalar>
        </Message>
      </MessageType>
      <MessageType id="done">
        <Documentation>Used to fan back in to a single exit point.</Documentation>
      </MessageType>
    </MessageTypes>
    <DeviceTypes>
      <DeviceType id="root">
        <Properties>
          <Scalar name="fineTotal" type="int32_t">
            <Documentation>Number of fine that we receive from (not nesc. that we send to)</Documentation>
          </Scalar>
          <Scalar name="inv_Adiag" type="float"/>
        </Properties>
        <State>
          <Scalar name="fineSeen" type="int32_t"/>
          <Scalar name="fineAcc" type="float"/>
          <Scalar name="fineMaxResidual" type="float"/>
          <Scalar name="steps" type="int32_t" />
        </State>
        <InputPin name="fine_up" messageTypeId="fine_to_coarse">
          <Properties>
            <Scalar name="R" type="float">
              <Documentation>The component of R for this edge.</Documentation>
            </Scalar>
          </Properties>
          <OnReceive><![CDATA[
            assert(deviceState->fineSeen < deviceProperties->fineTotal);
            deviceState->fineSeen++;
            deviceState->fineAcc += edgeProperties->R*message->b;
            deviceState->fineMaxResidual = std::max(deviceState->fineMaxResidual, message->max_r);
            handler_log(3, "maxMaxResidual=%g", deviceState->fineMaxResidual);
            ]]></OnReceive>
        </InputPin>
        <OutputPin name="fine_down" messageTypeId="coarse_to_fine">
          <OnSend><![CDATA[
            assert(deviceState->fineSeen == deviceProperties->fineTotal);

            message->x = deviceState->fineAcc * deviceProperties->inv_Adiag;
            message->max_r = deviceState->fineMaxResidual;
            handler_log(3, "msg.maxMaxResidual=%g", deviceState->fineMaxResidual);
            assert(message->max_r>=0);

            handler_log(1, "steps=%d, msg.maxMaxResidual=%g", deviceState->steps, deviceState->fineMaxResidual);

            deviceState->fineSeen=0;
            deviceState->fineAcc=0;
            deviceState->fineMaxResidual=0;
            deviceState->steps += 1;

            ]]></OnSend>
        </OutputPin>
        <ReadyToSend><![CDATA[
        *readyToSend = deviceState->fineSeen == deviceProperties->fineTotal ? RTS_FLAG_fine_down : 0;
        handler_log(2, "root RTS : 0x%x", *readyToSend);
        ]]></ReadyToSend>
      </DeviceType>
      <DeviceType id="branch">
        <Documentation>This is a middle tier solver, so it is only involved in
        the sweep up and down.
        </Documentation>
        <Properties>
          <Scalar name="fineCount" type="int32_t">
            <Documentation>Number of fine that we receive from (not nesc. send to).</Documentation>
          </Scalar>
          <Scalar name="peerCount" type="int32_t">
            <Documentation>Number of peers that we receive from (not nesc. send to).</Documentation>
          </Scalar>
          <Scalar name="coarseCount" type="int32_t">
            <Documentation>Number of coarse that we receive from (not nesc. send to).</Documentation>
          </Scalar>
          <Scalar name="Ad" type="float"/>
          <Scalar name="AdInvOmega" type="float"/>
          <Scalar name="omega" type="float"/>
        </Properties>
        <State>
          <Scalar name="state" type="int32_t"/>
          <Scalar name="b" type="float">
            <Documentation>Current problem RHS</Documentation>
          </Scalar>
          <Scalar name="x" type="float">
            <Documentation>Current problem guess</Documentation>
          </Scalar>
          <Scalar name="max_r" type="float">
            <Documentation>Global worst residual</Documentation>
          </Scalar>
          <Scalar name="fineSeen" type="int32_t"/>
          <Scalar name="fineAcc" type="float"/>
          <Scalar name="fineMaxResidual" type="float"/>
          <Scalar name="preSmoothSeen" type="int32_t"/>
          <Scalar name="preSmoothAcc" type="float"/>
          <Scalar name="preResidualSeen" type="int32_t"/>
          <Scalar name="preResidualAcc" type="float"/>
          <Scalar name="coarseSeen" type="int32_t"/>
          <Scalar name="coarseAcc" type="float"/>
          <Scalar name="postSmoothSeen" type="int32_t"/>
          <Scalar name="postSmoothAcc" type="float"/>
        </State>
        <SharedCode><![CDATA[

        /*
        We now share the actual declaration of states, even though semantics are
        slightly different in device types.

        enum State{
            State_Idle,         // Waiting for a problem to solve
                                // [fineSeen==fineCount] : send/peer_out -> State_PreSmooth

            State_PreSmooth,    // Doing the first smoothing step
                                // [preSmoothSeen==peerCount] : send/peer_out -> State_Pre

            State_PreResidual,  // Exchange for residual
                                // [preResidSeen==peerCount] : send/peer_out -> State_Pre

            State_Coarse,       // Waiting till we get a message back from coarse
                                // [coarseSeen==coarseCount] : send/peer_out -> State_PostSmooth

            State_PostSmooth    // Doing final smoothing before returning
                                // [postSmoothSeen==peerCount] : send/coarse_down -> State_Idle
        };
        */

        ]]></SharedCode>
        <InputPin name="fine_up" messageTypeId="fine_to_coarse">
          <Properties>
            <Scalar name="R" type="float"/>
          </Properties>
          <OnReceive><![CDATA[
            assert(deviceState->state==State_Idle);
            assert(deviceState->fineSeen < deviceProperties->fineCount);

            deviceState->fineSeen++;  // Might enable send on peer_out
            deviceState->fineAcc+=edgeProperties->R * message->b;
            assert(message->max_r>=0);
            deviceState->fineMaxResidual=std::max(deviceState->fineMaxResidual, message->max_r);
            assert(deviceState->fineMaxResidual>=0);

            handler_log(2, "fineSeen=%d, fineAcc=%f", deviceState->fineSeen, deviceState->fineAcc);
            ]]></OnReceive>
        </InputPin>
        <InputPin name="peer_in" messageTypeId="jacobi_exchange">
          <Properties>
            <Scalar name="A" type="float"/>
          </Properties>
          <OnReceive><![CDATA[
            // This can happen in any state at all
            switch(message->tag){
            case State_PreSmooth:
                assert(deviceState->preSmoothSeen < deviceProperties->peerCount);
                deviceState->preSmoothSeen++;
                deviceState->preSmoothAcc+=message->x * edgeProperties->A;
                break;
            case State_PreResidual:
                assert(deviceState->preResidualSeen < deviceProperties->peerCount);
                deviceState->preResidualSeen++;
                deviceState->preResidualAcc+=message->x * edgeProperties->A;
                break;
            case State_PostSmooth:
                assert(deviceState->postSmoothSeen < deviceProperties->peerCount);
                deviceState->postSmoothSeen++;
                deviceState->postSmoothAcc+=message->x * edgeProperties->A;
                break;
            default:
                assert(0);
                break;
            }
            ]]></OnReceive>
        </InputPin>
        <InputPin name="coarse_down" messageTypeId="coarse_to_fine">
          <Properties>
            <Scalar name="P" type="float"/>
          </Properties>
          <OnReceive><![CDATA[
            assert(deviceState->state == State_Coarse);
            assert(deviceState->coarseSeen < deviceProperties->coarseCount);
            assert(message->max_r >= 0);

            if(!(deviceState->max_r == -1 || deviceState->max_r==message->max_r)){
              handler_log(0, "coarse_down/receive: deviceState->max_r=%g, message->max_r=%g", deviceState->max_r, message->max_r);
            }
            // We should receive exactly the same max_r from _all_ coarse nodes, as it all comes from one root.
            assert(deviceState->max_r == -1 || deviceState->max_r==message->max_r);

            deviceState->coarseSeen++;   // This may enable sending on fine_down
            deviceState->coarseAcc += edgeProperties->P * message->x;
            deviceState->max_r = message->max_r;

            handler_log(2, "coarseSeen=%d", deviceState->coarseSeen);
            ]]></OnReceive>
        </InputPin>
        <OutputPin name="peer_out" messageTypeId="jacobi_exchange">
          <OnSend><![CDATA[

            if(deviceState->state==State_Idle){
                assert(deviceState->fineSeen == deviceProperties->fineCount);

                deviceState->x=0;
                deviceState->b=deviceState->fineAcc;
                deviceState->fineSeen=0;
                deviceState->fineAcc=0;

                message->x=deviceState->x;
                message->tag=State_PreSmooth;

                deviceState->state=State_PreSmooth;
                handler_log(2, "Idle->Pre");
            }else if(deviceState->state==State_PreSmooth){
                assert(deviceState->preSmoothSeen==deviceProperties->peerCount);

                float dx =(deviceState->b - deviceState->preSmoothAcc) * deviceProperties->AdInvOmega
                                - deviceProperties->omega * deviceState->x;

                deviceState->x += dx; // We are only smoothing here, residual will be done on send/coarse_down or send/coarse_up
                deviceState->preSmoothSeen=0;
                deviceState->preSmoothAcc=0;

                message->x=deviceState->x;
                message->tag=State_PreResidual;

                deviceState->state=State_PreResidual;
                handler_log(2, "PreSmooth->PreResidual");
            }else if(deviceState->state==State_Coarse){
                assert(deviceState->coarseSeen == deviceProperties->coarseCount);
                assert(deviceState->max_r >= 0);

                deviceState->x += deviceState->coarseAcc;
                deviceState->coarseSeen=0;
                deviceState->coarseAcc=0;

                message->x=deviceState->x;
                message->tag=State_PostSmooth;

                handler_log(2, "Coarse->PostSmooth");
                deviceState->state=State_PostSmooth;
            }else{
                assert(0);
            }
            ]]></OnSend>
        </OutputPin>
        <OutputPin name="coarse_up" messageTypeId="fine_to_coarse">
          <OnSend><![CDATA[
            assert(deviceState->state==State_PreResidual);
            assert(deviceState->preResidualSeen==deviceProperties->peerCount);

            float r  = deviceState->b - deviceState->preResidualAcc - deviceProperties->Ad * deviceState->x;

            message->b = r;  // local residual to solve
            message->max_r = deviceState->fineMaxResidual; // This is propagating the worst from any point on the grid

            deviceState->fineMaxResidual=0;
            deviceState->preResidualSeen=0;
            deviceState->preResidualAcc=0;

            deviceState->state=State_Coarse;

            handler_log(2, "PreResidual->Coarse");
            ]]></OnSend>
        </OutputPin>
        <OutputPin name="fine_down" messageTypeId="coarse_to_fine">
          <OnSend><![CDATA[
            assert(deviceState->state==State_PostSmooth);
            assert(deviceState->postSmoothSeen==deviceProperties->peerCount);
            assert(deviceState->max_r>=0);

            float dx =(deviceState->b - deviceState->postSmoothAcc) * deviceProperties->AdInvOmega
                - deviceProperties->omega * deviceState->x;

            deviceState->x += dx;
            deviceState->postSmoothSeen=0;
            deviceState->postSmoothAcc=0;
            deviceState->state=State_Idle;
            handler_log(2, "Post->Idle");

            message->x = deviceState->x;
            message->max_r = deviceState->max_r;

            deviceState->max_r = -1;
            ]]></OnSend>
        </OutputPin>
        <ReadyToSend><![CDATA[
            *readyToSend = 0;
            switch(deviceState->state){
            case State_Idle:
                if(deviceState->fineSeen==deviceProperties->fineCount){
                    *readyToSend |= RTS_FLAG_peer_out;
                }
                break;
            case State_PreSmooth:
                if(deviceState->preSmoothSeen==deviceProperties->peerCount){
                    *readyToSend |= RTS_FLAG_peer_out; // exchange for the residual
                }
                break;
            case State_PreResidual:
                if(deviceState->preResidualSeen==deviceProperties->peerCount){
                    *readyToSend |= RTS_FLAG_coarse_up; // send to the coarse refinement
                }
                break;
            case State_Coarse:
                if(deviceState->coarseSeen==deviceProperties->coarseCount){
                    *readyToSend |= RTS_FLAG_peer_out; // exchange for final smooth
                }
                break;
            case State_PostSmooth:
                if(deviceState->postSmoothSeen==deviceProperties->peerCount){
                    *readyToSend |= RTS_FLAG_fine_down; // Seen it back down tree
                }
                break;
            default:
                assert(0);
                break;
            }
        ]]></ReadyToSend>
        <OnInit><![CDATA[
        assert(deviceProperties->coarseCount>0);
        assert(deviceProperties->peerCount>0);

        deviceState->max_r = -1;
        ]]></OnInit>
      </DeviceType>
      <DeviceType id="leaf">
        <Documentation>This is the finest level linear solver, with one device per element in
        the original problem matrix. The finest is not the same as the middle-tier
        nodes, as it needs to control the iteration until residual is met (though this
        could be controlled by a property and a state).
        </Documentation>
        <Properties>
          <Scalar name="peerCount" type="int32_t">
            <Documentation>Number of peers that we receive from (not nesc. send to).</Documentation>
          </Scalar>
          <Scalar name="coarseCount" type="int32_t">
            <Documentation>Number of coarse that we receive from (not nesc. send to).</Documentation>
          </Scalar>
          <Scalar name="Ad" type="float"/>
          <Scalar name="AdInvOmega" type="float"/>
          <Scalar name="omega" type="float"/>
        </Properties>
        <State>
          <Scalar name="state" type="int32_t"/>
          <Scalar name="b" type="float">
            <Documentation>Current problem RHS</Documentation>
          </Scalar>
          <Scalar name="x" type="float">
            <Documentation>Current problem guess</Documentation>
          </Scalar>
          <Scalar name="r" type="float">
            <Documentation>Global worst residual</Documentation>
          </Scalar>
          <Scalar name="preSmoothSeen" type="int32_t"/>
          <Scalar name="preSmoothAcc" type="float"/>
          <Scalar name="preResidualSeen" type="int32_t"/>
          <Scalar name="preResidualAcc" type="float"/>
          <Scalar name="coarseSeen" type="int32_t"/>
          <Scalar name="coarseAcc" type="float"/>
        </State>
        <SharedCode><![CDATA[

        /*
        We now share the actual declaration of states, even though semantics are
        slightly different in device types.

        enum State{
            State_Idle,         // Waiting for a problem to solve
                                // [r > residualTolerance] : send/peer_out -> State_PreSmooth

            State_PreSmooth,    // Doing the first smoothing step
                                // [preSmoothSeen==peerCount] : send/peer_out -> State_Pre

            State_PreResidual,  // Exchange for residual
                                // [preResidualSeen==peerCount] : send/peer_out -> State_Pre

            State_Coarse       // Waiting till we get a message back from coarse
                                // [coarseSeen==coarseCount ^ r <= residualTolerance] : send/fine_down -> State_Idle
                                // [coarseSeen==coarseCount ^ r > residualTolerance]  : send/peer_out -> State_PreSmooth

        };
        */

        ]]></SharedCode>
        <InputPin name="problem" messageTypeId="linear_problem">
          <OnReceive><![CDATA[
            assert(deviceState->state==State_Idle);
            assert(deviceState->r ==0 ); // Must have finished the previous problem...

            deviceState->b = message->b;
            deviceState->x = message->x;
            deviceState->r = FLT_MAX;     // This will trigger RTS for peer_out
            ]]></OnReceive>
        </InputPin>
        <InputPin name="peer_in" messageTypeId="jacobi_exchange">
          <Properties>
            <Scalar name="A" type="float"/>
          </Properties>
          <OnReceive><![CDATA[
            // This can happen in any state at all
            switch(message->tag){
            case State_PreSmooth:
                assert(deviceState->preSmoothSeen < deviceProperties->peerCount);
                deviceState->preSmoothSeen++;
                deviceState->preSmoothAcc+=message->x * edgeProperties->A;
                break;
            case State_PreResidual:
                assert(deviceState->preResidualSeen < deviceProperties->peerCount);
                deviceState->preResidualSeen++;
                deviceState->preResidualAcc+=message->x * edgeProperties->A;
                break;
            default:
                assert(0);
                break;
            }
            ]]></OnReceive>
        </InputPin>
        <InputPin name="coarse_down" messageTypeId="coarse_to_fine">
          <Properties>
            <Scalar name="P" type="float"/>
          </Properties>
          <OnReceive><![CDATA[
            assert(deviceState->state == State_Coarse);
            assert(deviceState->coarseSeen < deviceProperties->coarseCount);

            // We should receive exactly the same max_r from _all_ coarse nodes, as it all comes from one root.
            assert(deviceState->r == FLT_MAX || deviceState->r==message->max_r);

            deviceState->coarseSeen++;   // This may enable sending on either peer_out, or solution
            deviceState->coarseAcc += edgeProperties->P * message->x;
            deviceState->r = message->max_r;
            ]]></OnReceive>
        </InputPin>
        <OutputPin name="peer_out" messageTypeId="jacobi_exchange">
          <OnSend><![CDATA[
            if(deviceState->state==State_Idle){
                assert(deviceState->r >= graphProperties->residualTol);

                message->x=deviceState->x;
                message->tag=State_PreSmooth;

                deviceState->state=State_PreSmooth;
                handler_log(2, "Idle->Pre");
            }else if(deviceState->state==State_PreSmooth){
                assert(deviceState->preSmoothSeen==deviceProperties->peerCount);

                float dx =(deviceState->b - deviceState->preSmoothAcc) * deviceProperties->AdInvOmega
                                - deviceProperties->omega * deviceState->x;

                deviceState->x += dx; // We are only smoothing here, residual will be done on send/coarse_down or send/coarse_up
                deviceState->preSmoothSeen=0;
                deviceState->preSmoothAcc=0;

                message->x=deviceState->x;
                message->tag=State_PreResidual;

                deviceState->state=State_PreResidual;
                handler_log(2, "PreSmooth->PreResidual");
            }else if(deviceState->state==State_Coarse){
                assert(deviceState->coarseSeen == deviceProperties->coarseCount);
                assert(deviceState->r > graphProperties->residualTol); // Otherwise we would be sending the solution down

                deviceState->x += deviceState->coarseAcc;
                deviceState->coarseSeen=0;
                deviceState->coarseAcc=0;

                message->x=deviceState->x;
                message->tag=State_PreSmooth;

                handler_log(2, "Coarse->PreSmooth");
                deviceState->state=State_PreSmooth;
            }else{
                assert(0);
            }
            ]]></OnSend>
        </OutputPin>
        <OutputPin name="coarse_up" messageTypeId="fine_to_coarse">
          <OnSend><![CDATA[
            assert(deviceState->state==State_PreResidual);
            assert(deviceState->preResidualSeen ==deviceProperties->peerCount);

            float r  = deviceState->b - deviceState->preResidualAcc - deviceProperties->Ad * deviceState->x;

            message->b = r;
            message->max_r = std::abs(r) ;

            deviceState->preResidualSeen=0;
            deviceState->preResidualAcc=0;
            deviceState->r = FLT_MAX;
            deviceState->state=State_Coarse;
            ]]></OnSend>
        </OutputPin>
        <OutputPin name="solution" messageTypeId="linear_solution">
          <OnSend><![CDATA[
            assert(deviceState->state==State_Coarse);
            assert(deviceState->coarseSeen==deviceProperties->coarseCount);
            assert(deviceState->r <= graphProperties->residualTol); // We must have found a solution

            // Note that we _don't_ add the coarseCorrection, as we might make the residual worse
            // So we return the x for which we have calculated the worst residual
            message->x = deviceState->x;
            message->r = deviceState->r;

            deviceState->coarseSeen=0;
            deviceState->coarseAcc=0;
            deviceState->r=0;
            deviceState->state=State_Idle;
            ]]></OnSend>
        </OutputPin>
        <ReadyToSend><![CDATA[
            *readyToSend = 0;
            switch(deviceState->state){
            case State_Idle:
                if(deviceState->r > graphProperties->residualTol){
                    *readyToSend |= RTS_FLAG_peer_out;
                }
                break;
            case State_PreSmooth:
                if(deviceState->preSmoothSeen==deviceProperties->peerCount){
                    *readyToSend |= RTS_FLAG_peer_out;
                }
                break;
            case State_PreResidual:
                if(deviceState->preResidualSeen==deviceProperties->peerCount){
                    *readyToSend |= RTS_FLAG_coarse_up;
                }
                break;
            case State_Coarse:
                if(deviceState->coarseSeen==deviceProperties->coarseCount){
                    if(deviceState->r <= graphProperties->residualTol){
                        *readyToSend |= RTS_FLAG_solution;
                    }else{
                        *readyToSend |= RTS_FLAG_peer_out;
                    }
                }
                break;
            default:
                assert(0);
                break;
            }
            handler_log(3, "state=%d, coarseSeen=%d, coarseCount=%d", deviceState->state, deviceState->coarseSeen, deviceProperties->coarseCount);
        ]]></ReadyToSend>
      </DeviceType>
      <DeviceType id="tester">
        <Properties>
          <Array name="b" length="8" type="float"/>
          <Array name="x" length="8" type="float"/>
        </Properties>
        <State>
          <Scalar name="i" type="int32_t"/>
        </State>
        <InputPin name="solution" messageTypeId="linear_solution">
          <OnReceive><![CDATA[
            assert((deviceState->i&1)==1);
            assert(deviceState->i<16);

            auto rx=deviceProperties->x[deviceState->i/2];

            auto x = message->x;
            auto r = message->r;
            auto i = message->i;

            assert( (r>=0) && (r<graphProperties->residualTol) );

            handler_log(3, " iter=%d, x=%g (dx=%g), r=%g, i=%d\n\n\n", deviceState->i/2, x, std::abs(x-rx), r, i);

            deviceState->i++;
            ]]></OnReceive>
        </InputPin>
        <OutputPin name="finished" messageTypeId="done">
          <OnSend><![CDATA[
            assert(deviceState->i==16);
            // No payload
            deviceState->i++;
            ]]></OnSend>
        </OutputPin>
        <OutputPin name="problem" messageTypeId="linear_problem">
          <OnSend><![CDATA[
            assert((deviceState->i&1)==0);
            assert(deviceState->i<16);

            message->x = 5;
            message->b = deviceProperties->b[deviceState->i];
            deviceState->i++;
            ]]></OnSend>
        </OutputPin>
        <ReadyToSend><![CDATA[
        *readyToSend=0;
        if( (deviceState->i < 16) && (0==(deviceState->i&1)) ){
            *readyToSend=RTS_FLAG_problem;
        }else if(deviceState->i == 16){
            *readyToSend=RTS_FLAG_finished;
        }
        ]]></ReadyToSend>
      </DeviceType>
      <DeviceType id="exit">
        <Properties>
          <Scalar name="nodes" type="uint32_t"/>
        </Properties>
        <State>
          <Scalar name="seen" type="uint32_t"/>
        </State>
        <InputPin name="finished" messageTypeId="done">
          <OnReceive><![CDATA[
            deviceState->seen++;
            handler_log(1, "finished/done : seen=%u out of %u", deviceState->seen, deviceProperties->nodes);
            if(deviceState->seen==deviceProperties->nodes){
                fake_handler_exit(0);
            }
            ]]></OnReceive>
        </InputPin>
        <ReadyToSend><![CDATA[
        *readyToSend=0;
        ]]></ReadyToSend>
      </DeviceType>
    </DeviceTypes>
  </GraphType>
</Graphs>
