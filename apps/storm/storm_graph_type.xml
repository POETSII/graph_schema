<?xml version='1.0' encoding='ASCII'?>
<Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v3">
  <GraphType id="storm">
    <Documentation>
		A highly irregular and non-determinstic packet storm, but guaranteed to converge.

		One node starts with all the credit. Each node has outgoing
		pins with 1 and n edges. If a node has at least n credit it will randomly choose the
		pin, otherwise it uses the single edge pin to drain the credit. Each node attempts
		to lose credit as fast as possible.

		The starting node initially distributes all but 1 credit, and never releases credit
		again, so eventually all credit must return (though who knows how long it takes...)
	</Documentation>

	<SharedCode><![CDATA[
        #ifdef POETS_LEGACY_HAS_HANDLER_EXIT
        #define _do_handler_exit(code) handler_exit(code)
        #else
        #define _do_handler_exit(code) ((void)0)
        #endif

        #define fake_handler_exit(code) \
        { \
            if((code)==0){ \
                handler_log(0, "_HANDLER_EXIT_SUCCESS_9be65737_"); \
            }else{ \
                handler_log(0, "_HANDLER_EXIT_FAIL_9be65737_"); \
            } \
            _do_handler_exit(code); \
        }
]]></SharedCode>

    <MessageTypes>
      <MessageType id="exchange">
        <Message>
          <Scalar name="credit" type="uint32_t"/>
        </Message>
      </MessageType>
    </MessageTypes>
    <DeviceTypes>
      <DeviceType id="node">
        <Properties>
          <Scalar name="degree" type="uint32_t"/>
          <Scalar name="isRoot" type="uint32_t"/>
        </Properties>
        <State>
          <Scalar name="credit" type="uint32_t"/>
          <Scalar name="totalCredit" type="uint32_t"/>
        </State>
        <InputPin name="credit" messageTypeId="exchange">
          <OnReceive><![CDATA[
		  deviceState->credit += message->credit;
			handler_log(4, "Received %u credit, local credit is %u", message->credit, deviceState->credit);
			if(deviceProperties->isRoot && deviceState->credit==deviceState->totalCredit){
				fake_handler_exit(0);
			}
		  ]]></OnReceive>
        </InputPin>
        <OutputPin name="wide" messageTypeId="exchange">
          <OnSend><![CDATA[
		if(deviceProperties->isRoot){
			assert(deviceState->credit==0);
			uint32_t perDevice=1;
			while( perDevice * deviceProperties->degree < 0x10000000ul ){
				perDevice *= 2;
			}
			message->credit=perDevice;
			deviceState->credit=1;
			deviceState->totalCredit=1+perDevice * deviceProperties->degree;
		}else{
			assert(deviceState->credit >= deviceProperties->degree );
			uint32_t perDevice=1;
			while( (perDevice * 2) * deviceProperties->degree <= deviceState->credit){
				perDevice *= 2;
			}
			message->credit=perDevice;
			deviceState->credit -= perDevice*deviceProperties->degree;
		}
		handler_log(4, "Sending %u credit wide, local credit is %u", message->credit, deviceState->credit);
		]]></OnSend>
        </OutputPin>
        <OutputPin name="narrow" messageTypeId="exchange">
          <OnSend><![CDATA[
		assert(!deviceProperties->isRoot);
		assert(deviceState->credit > 0);
		message->credit=(deviceState->credit+1)/2;
		deviceState->credit -= message->credit;
		handler_log(4, "Sending %u credit narrow, local credit is %u", message->credit, deviceState->credit);

		]]></OnSend>
        </OutputPin>
        <ReadyToSend><![CDATA[
			*readyToSend = 0;
			if(deviceProperties->isRoot){
				if(deviceState->credit==0){
					*readyToSend = RTS_FLAG_wide;
				}
			}else{
				if(deviceState->credit >= deviceProperties->degree){
					uint32_t b=1664525*deviceState->credit+1013904223;
					if( (b>>30)==0 ){
				 		*readyToSend = RTS_FLAG_wide;
					}else{
						*readyToSend = RTS_FLAG_narrow;
					}
				}else if(deviceState->credit > 0 ){
					*readyToSend = RTS_FLAG_narrow;
				}
			}
		]]></ReadyToSend>
      </DeviceType>
    </DeviceTypes>
  </GraphType>
</Graphs>
